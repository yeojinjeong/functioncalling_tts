import os
import json
import uuid
import requests
import streamlit as st
from dotenv import load_dotenv
from pydub import AudioSegment  # ë³‘í•©ì„ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬

# í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
load_dotenv()
HCX_API_KEY = os.getenv("HCX_API_KEY")
NAVER_CLIENT_ID = os.getenv("NAVER_CLIENT_ID")
NAVER_CLIENT_SECRET = os.getenv("NAVER_CLIENT_SECRET")
MODEL_NAME = "HCX-DASH-002"
BASE_URL = f"https://clovastudio.stream.ntruss.com/testapp/v3/chat-completions/{MODEL_NAME}"

# ì§€ì› ê°€ëŠ¥í•œ TTS í™”ì ëª©ë¡
SPEAKERS = [
    "ndaeseong", "ndain", "ndonghyun", "nes_c_hyeri", "nes_c_kihyo",
    "nes_c_mikyung", "nes_c_sohyun", "neunseo", "neunwoo"
]

# HCX Function Calling í˜¸ì¶œ í•¨ìˆ˜
def send_hcx_function_calling(messages, functions=None, temperature=0.7, top_p=0.9, max_tokens=512):
    headers = {
        "Authorization": f"Bearer {HCX_API_KEY}",
        "Content-Type": "application/json"
    }
    payload = {
        "messages": messages,
        "functions": functions or [],
        "function_call": "auto",
        "seed": 0,
        "topP": top_p,
        "topK": 0,
        "maxTokens": max_tokens,
        "temperature": temperature,
        "repeatPenalty": 1.1,
        "stopBefore": []
    }
    resp = requests.post(BASE_URL, headers=headers, json=payload)
    resp.raise_for_status()
    return resp.json()

# íŒŸìºìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± í•¨ìˆ˜
def generate_script(topic):
    tools = [
        {
            "type": "function",
            "function": {
                "name": "generate_script",
                "description": "ì£¼ì œ ê¸°ë°˜ìœ¼ë¡œ ì§§ì€ íŒŸìºìŠ¤íŠ¸ ëŒ€ë³¸ì„ ìƒì„±í•©ë‹ˆë‹¤. ëŒ€ë³¸ì€ ë°œí™”ì 2ëª…ìœ¼ë¡œë§Œ êµ¬ì„±í•´ì„œ ìƒì„±. ëŒ€ë³¸ í˜•ì‹ìœ¼ë¡œ ì¶œë ¥í•˜ê¸°",
                "parameters": {
                    "type": "object",
                    "properties": {"topic": {"type": "string", "description": "íŒŸìºìŠ¤íŠ¸ ì£¼ì œ"}},
                    "required": ["topic"]
                }
            }
        }
    ]
    messages = [
        {"role": "system", "content": "íŒŸìºìŠ¤íŠ¸ ëŒ€ë³¸ ìƒì„±ê¸°"},
        {"role": "user", "content": topic}
    ]
    resp = send_hcx_function_calling(messages, functions=tools)
    return resp.get("result", {}).get("message", {}).get("content", "")

# TTS API í˜¸ì¶œ í•¨ìˆ˜
def generate_tts(text, speaker, speed=0):
    url = "https://naveropenapi.apigw.ntruss.com/tts-premium/v1/tts"
    headers = {
        "X-NCP-APIGW-API-KEY-ID": NAVER_CLIENT_ID,
        "X-NCP-APIGW-API-KEY": NAVER_CLIENT_SECRET,
        "Content-Type": "application/x-www-form-urlencoded"
    }
    data = {"speaker": speaker, "speed": str(speed), "format": "mp3", "text": text}
    r = requests.post(url, headers=headers, data=data)
    r.raise_for_status()
    filename = f"tts_{speaker}_{uuid.uuid4().hex[:6]}.mp3"
    with open(filename, "wb") as f:
        f.write(r.content)
    return filename

# ì˜¤ë””ì˜¤ ë³‘í•© í•¨ìˆ˜
def merge_audio_files(mp3_paths, output_path="final_podcast.mp3"):
    combined = AudioSegment.empty()
    for path in mp3_paths:
        audio = AudioSegment.from_file(path, format="mp3")
        combined += audio
    combined.export(output_path, format="mp3")
    return output_path

# Streamlit UI
st.set_page_config(page_title="ğŸ™ï¸ íŒŸìºìŠ¤íŠ¸ ìƒì„± & TTS", layout="centered")
st.title("ğŸ™ï¸ HyperCLOVA X íŒŸìºìŠ¤íŠ¸ ì œì‘ê¸°")

# ì…ë ¥
topic = st.text_input("íŒŸìºìŠ¤íŠ¸ ì£¼ì œë¥¼ ì…ë ¥í•˜ì„¸ìš”:")
selected_speakers = st.multiselect(
    "TTS ëª©ì†Œë¦¬ ë‘ ê°œë¥¼ ì„ íƒí•˜ì„¸ìš”:",
    options=SPEAKERS,
    default=SPEAKERS[:2],
    help="ë¦¬ìŠ¤íŠ¸ì—ì„œ ë‘ ê°œì˜ í™”ìë¥¼ ì„ íƒí•˜ì„¸ìš”"
)

if topic:
    if len(selected_speakers) != 2:
        st.error("í™”ìë¥¼ ì •í™•íˆ ë‘ ëª… ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.")
    else:
        with st.spinner("ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì¤‘..."):
            try:
                script = generate_script(topic)
            except Exception as e:
                st.error(f"ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì˜¤ë¥˜: {e}")
                st.stop()
        st.subheader("ìƒì„±ëœ íŒŸìºìŠ¤íŠ¸ ëŒ€ë³¸")
        st.text(script)

        lines = [line.strip() for line in script.splitlines() if line.strip()]
        audio_files = []
        for idx, line in enumerate(lines):
            _, utter = line.split(":", 1) if ":" in line else (None, line)
            speaker = selected_speakers[idx % 2]
            try:
                path = generate_tts(utter, speaker=speaker)
                audio_files.append((speaker, path))
            except Exception as e:
                st.error(f"TTS ë³€í™˜ ì˜¤ë¥˜ (ë¼ì¸ {idx+1}): {e}")

        # ê°œë³„ ì˜¤ë””ì˜¤ ì¶œë ¥
        st.subheader("ìƒì„±ëœ íŒŸìºìŠ¤íŠ¸ ìŒì„±")
        for i, (spk, fpath) in enumerate(audio_files, 1):
            st.markdown(f"**Segment {i} ({spk})**")
            with open(fpath, "rb") as f:
                st.audio(f.read(), format="audio/mp3")

        # ë³‘í•©ëœ ì˜¤ë””ì˜¤ ì¶œë ¥
        try:
            st.subheader("ğŸ§ ë³‘í•©ëœ ì „ì²´ íŒŸìºìŠ¤íŠ¸ ì˜¤ë””ì˜¤")
            merged_path = merge_audio_files([f for _, f in audio_files])
            with open(merged_path, "rb") as f:
                merged_audio = f.read()
                st.audio(merged_audio, format="audio/mp3")
                st.download_button("ğŸ“¥ ë³‘í•©ëœ ì˜¤ë””ì˜¤ ë‹¤ìš´ë¡œë“œ", merged_audio, file_name=merged_path)
        except Exception as e:
            st.error(f"ë³‘í•© ì˜¤ë¥˜: {e}")
